// Add various requirements.
var http = require('http'),
    https = require('https'),
    connect = require('connect'),
    httpProxy = require('http-proxy');
var fs = require('fs');
var esprima = require('esprima');
var escodegen = require('escodegen');
var estraverse = require('estraverse');

// Information for injecting the javascript code.
var selects = [];
var simpleselect = {};
var blocks = [];

// On scripts, we gather the code and add various injected pieces as necessary
simpleselect.query = 'script';
simpleselect.func = function (node) {
  var input = '';    
  //console.log("start input" + input);

  var readStream = node.createReadStream();
  var writeStream = node.createWriteStream();

  readStream.on('data', function(data){
    input += data.toString();
  })

  readStream.on('end', function(){
    var ast = esprima.parse(input);
    var blocks = [];
    blocks.push(ast.body);

    estraverse.traverse(ast, {
      enter: enter,
      leave: leave
    });
    if (input == ''){
      writeStream.end('');
    }
    else{
      // add object declaration to beginning
      ast.body.unshift(esprima.parse('if (!obj){ var obj = {"resolution" : 0, "gamut" : 0, "color_depth" : 0, "cpu" : 0, "contrast" : 0, "memory" : 0, "concurrency" : 0, "hdr" : 0, "inverted_colors" : 0, "color_depth" : 0}; };'));

      // add stat display code to end
      ast.body.push(esprima.parse('for (var key in obj){ console.log(`${key} count: ${obj[key]}`);}'));
      
      var out = escodegen.generate(ast);

      console.log("\nProcessed JavaScript:\n")
      console.log(out);
      
      //node.createWriteStream().end('<div>+ Trumpet</div>');    
      writeStream.end(out); 
    }
    
  });
}

selects.push(simpleselect);

//
// Basic Connect App
//
var app = connect();

var proxy = httpProxy.createProxyServer({
   // target: 'https://nodejs.org',
   // agent  : https.globalAgent, 
   // headers:{ host: 'nodejs.org' 
   secure: false,
   target: 'https://www.cnn.com',
   agent  : https.globalAgent, 
   headers:{ host: 'www.cnn.com' }
})


app.use(require('../')([], selects, true));

app.use(
  function (req, res) {
    proxy.web(req, res);
  }
);

http.createServer(app).listen(8000);

// function enter(node){
//   if (node.type === 'BlockStatement'){
//     blocks.push(node.body);
//   }
//   if (node.type === 'Identifier'){
//     if (node.name === 'width'){
//       var curblock = blocks[blocks.length - 1];
//       var toadd = esprima.parse('console.log("width extracted");').body[0];
//       curblock.push(toadd);
//     }
//   }
// }

// function leave(node){
//   if (node.type === 'BlockStatement'){
//     blocks.pop();
//   }
// }

// function enter(node){
//   if (node.type === 'BlockStatement'){
//     blocks.push(node.body);
//   }
//   if (node.type === 'Identifier'){
//     if (node.name === 'width'){
//       var curblock = blocks[blocks.length - 1];
//       //var start = esprima.parse('var obj = obj || {"resolution" : 0, "gamut" : 0};');
//       //curblock.push(start);
//       var toadd = esprima.parse('obj["resolution"] += 1;').body[0];
//       curblock.push(toadd);
//       var toend = esprima.parse('for (var key in obj){ console.log(`${key} count: ${obj[key]}`);}');
//       curblock.push(toend);
//     }
//   }
//   if (node.type === 'TemplateElement'){
//     if (node.value.raw.includes('color-gamut:')){
//       var curblock = blocks[blocks.length - 1];
//       //var start = esprima.parse('var obj = obj || {"resolution" : 0, "gamut" : 0};')
//       //curblock.push(start);
//       var toadd = esprima.parse('obj["gamut"] += 1;').body[0];
//       curblock.push(toadd);
//       var toend = esprima.parse('for (var key in obj){ console.log(`${key} count: ${obj[key]}`);}');
//       curblock.push(toend);
//     }
//   }
// }

// function leave(node){
//   if (node.type === 'BlockStatement'){
//     blocks.pop();
//   }
// }
function enter(node){
  if (node.type === 'BlockStatement'){
    blocks.push(node.body);
  }
  var curblock = blocks[blocks.length - 1];

  var toend = esprima.parse('console.log("Output"); for (var key in obj){ console.log(`${key} count: ${obj[key]}`);}');

  var toeval = 'curblock.push(toadd); curblock.push(toend);';
  // if inside a function definition, add line before return statement
  if (curblock && curblock.length > 0) {
    if (curblock[curblock.length - 1].type === 'ReturnStatement'){
    toeval = 'curblock.splice(curblock.length - 1, 0, toadd); curblock.splice(curblock.length - 1, 0, toend);'
    }
  } 
  // else {
  //   toeval = 'curblock = [];' + toeval;
  // }

  if (node.type === 'Identifier'){
    if (node.name.includes('height') || node.name.includes('width')){
      var toadd = esprima.parse('obj["resolution"] += 1;').body[0];
      eval(toeval);
    } else if (node.name.includes('oscpu') || node.name.includes('cpuClass') || node.name.includes('platform')) {
      var toadd = esprima.parse('obj["cpu"] += 1;').body[0];
      eval(toeval);
    } else if (node.name.includes('deviceMemory')){
      var toadd = esprima.parse('obj["memory"] += 1;').body[0];
      eval(toeval);
    } else if (node.name.includes('hardwareConcurrency')){
      var toadd = esprima.parse('obj["concurrency"] += 1;').body[0];
      eval(toeval);
    } else if (node.name.includes('colorDepth')){
      var toadd = esprima.parse('obj["color_depth"] += 1;').body[0];
      eval(toeval);
    }
  } else if (node.type === 'TemplateElement'){
    if (node.value.raw.includes('color-gamut')){
      var toadd = esprima.parse('obj["gamut"] += 1;').body[0];
      eval(toeval);
    } else if (node.value.raw.includes('prefers-contrast')){
      var toadd = esprima.parse('obj["contrast"] += 1;').body[0];
      eval(toeval);
    } else if (node.value.raw.includes('dynamic-range')){
      var toadd = esprima.parse('obj["hdr"] += 1;').body[0];
      eval(toeval);
    } else if (node.value.raw.includes('inverted-colors')){
      var toadd = esprima.parse('obj["inverted_colors"] += 1;').body[0];
      eval(toeval);
    }
  }
}

function leave(node){
  if (node.type === 'BlockStatement'){
    blocks.pop();
  }
}
